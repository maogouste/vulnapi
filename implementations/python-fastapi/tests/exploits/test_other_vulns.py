"""
Other Vulnerability Tests (V03, V05, V08, V09)

V03: Excessive Data Exposure
V05: Mass Assignment
V08: Security Misconfiguration
V09: Improper Assets Management
"""

import pytest


class TestExcessiveDataExposure:
    """Tests for V03 - Excessive Data Exposure."""

    @pytest.mark.asyncio
    async def test_user_response_exposes_sensitive_data(self, client, admin_token):
        """V03: User endpoint returns sensitive fields."""
        headers = {"Authorization": f"Bearer {admin_token}"}

        response = await client.get("/api/me", headers=headers)
        assert response.status_code == 200

        data = response.json()
        sensitive_fields = ["ssn", "credit_card", "api_key", "secret_note", "password_hash"]
        exposed = [f for f in sensitive_fields if f in data]

        # VULNERABILITY: Sensitive fields in response
        assert len(exposed) > 0, f"Expected sensitive fields, found: {list(data.keys())}"

    @pytest.mark.asyncio
    async def test_product_internal_data_exposed(self, client, admin_token):
        """V03: Product endpoint exposes internal data."""
        headers = {"Authorization": f"Bearer {admin_token}"}

        response = await client.get("/api/products", headers=headers)
        if response.status_code == 200 and response.json():
            product = response.json()[0]
            internal_fields = ["supplier_cost", "internal_notes", "margin"]
            exposed = [f for f in internal_fields if f in product]

            # VULNERABILITY: Internal business data exposed
            # May or may not be present depending on implementation


class TestMassAssignment:
    """Tests for V05 - Mass Assignment / Broken Function Level Authorization."""

    @pytest.mark.asyncio
    async def test_can_assign_admin_role(self, client, admin_token):
        """V05: User can escalate to admin via mass assignment."""
        headers = {"Authorization": f"Bearer {admin_token}"}

        # Get current user
        me_response = await client.get("/api/me", headers=headers)
        assert me_response.status_code == 200
        my_id = me_response.json()["id"]

        # Try to set role - even if already admin, test the field is accepted
        response = await client.put(
            f"/api/users/{my_id}",
            headers=headers,
            json={"role": "admin", "email": "test@test.com"}
        )

        # VULNERABILITY: Endpoint accepts role field
        assert response.status_code in [200, 403, 422]

    @pytest.mark.asyncio
    async def test_can_modify_is_active(self, client, admin_token):
        """V05: User can modify is_active field."""
        headers = {"Authorization": f"Bearer {admin_token}"}

        me_response = await client.get("/api/me", headers=headers)
        assert me_response.status_code == 200
        my_id = me_response.json()["id"]

        response = await client.put(
            f"/api/users/{my_id}",
            headers=headers,
            json={"is_active": True}
        )

        # VULNERABILITY: Should not be able to modify is_active
        assert response.status_code in [200, 403, 422]


class TestSecurityMisconfiguration:
    """Tests for V08 - Security Misconfiguration."""

    @pytest.mark.asyncio
    async def test_debug_endpoint_exposed(self, client, admin_token):
        """V08: Debug endpoint accessible."""
        headers = {"Authorization": f"Bearer {admin_token}"}

        response = await client.get("/api/tools/debug", headers=headers)

        if response.status_code == 200:
            data = response.json()
            # VULNERABILITY: Debug info exposed
            sensitive_keys = ["environment", "config", "settings", "debug"]
            found = any(k in str(data).lower() for k in sensitive_keys)
            assert found or len(data) > 0, "Debug endpoint exposes sensitive info"

    @pytest.mark.asyncio
    async def test_cors_allows_all_origins(self, client):
        """V08: CORS allows all origins."""
        response = await client.options(
            "/api/products",
            headers={
                "Origin": "https://evil.com",
                "Access-Control-Request-Method": "GET",
            }
        )

        acao = response.headers.get("access-control-allow-origin", "")
        # VULNERABILITY: Wildcard or reflected origin
        assert acao == "*" or acao == "https://evil.com", "CORS is permissive"

    @pytest.mark.asyncio
    async def test_missing_security_headers(self, client):
        """V08: Security headers missing."""
        response = await client.get("/")

        missing = []
        security_headers = [
            "strict-transport-security",
            "x-content-type-options",
            "x-frame-options",
            "content-security-policy",
        ]

        for header in security_headers:
            if header not in [h.lower() for h in response.headers.keys()]:
                missing.append(header)

        # VULNERABILITY: Security headers not set
        assert len(missing) > 0, "Expected missing security headers"

    @pytest.mark.asyncio
    async def test_server_header_exposed(self, client):
        """V08: Server header reveals technology."""
        response = await client.get("/")

        server = response.headers.get("server", "")
        # Check if server header reveals technology
        if server:
            tech_indicators = ["uvicorn", "gunicorn", "nginx", "apache", "python"]
            found = any(t in server.lower() for t in tech_indicators)
            # VULNERABILITY: Server technology exposed
            assert found or len(server) > 0


class TestImproperAssetsManagement:
    """Tests for V09 - Improper Assets Management."""

    @pytest.mark.asyncio
    async def test_legacy_api_accessible(self, client, admin_token):
        """V09: Legacy API version still accessible."""
        headers = {"Authorization": f"Bearer {admin_token}"}

        response = await client.get("/api/v1/users", headers=headers)

        # VULNERABILITY: Old API version still works
        assert response.status_code in [200, 401]

    @pytest.mark.asyncio
    async def test_legacy_api_exposes_more_data(self, client, admin_token):
        """V09: Legacy API exposes password hash."""
        headers = {"Authorization": f"Bearer {admin_token}"}

        response = await client.get("/api/v1/users", headers=headers)

        if response.status_code == 200:
            data = response.json()
            if isinstance(data, list) and len(data) > 0:
                user = data[0]
                # VULNERABILITY: Password hash exposed in legacy API
                if "password_hash" in user or "password" in user:
                    assert True, "Legacy API exposes password hash"
                    return

        # Test that endpoint exists even if data isn't exposed
        assert response.status_code in [200, 401]

    @pytest.mark.asyncio
    async def test_legacy_api_no_auth(self, client):
        """V09: Legacy API accessible without authentication."""
        response = await client.get("/api/v1/users")

        # VULNERABILITY: No auth required on legacy endpoint
        if response.status_code == 200:
            assert True, "Legacy API accessible without auth"
